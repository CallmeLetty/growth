<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>背景 | Yakamoz</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Keep learning.Keep explorating.">
    
    <link rel="preload" href="./growth/assets/css/0.styles.aa31e347.css" as="style"><link rel="preload" href="./growth/assets/js/app.aeb4fdc6.js" as="script"><link rel="preload" href="./growth/assets/js/2.63c13255.js" as="script"><link rel="preload" href="./growth/assets/js/9.f112da3c.js" as="script"><link rel="prefetch" href="./growth/assets/js/3.2707812c.js"><link rel="prefetch" href="./growth/assets/js/4.94733d25.js"><link rel="prefetch" href="./growth/assets/js/5.2ea06e07.js"><link rel="prefetch" href="./growth/assets/js/6.8d81f0ec.js"><link rel="prefetch" href="./growth/assets/js/7.553f1ea1.js"><link rel="prefetch" href="./growth/assets/js/8.2d51bb22.js">
    <link rel="stylesheet" href="./growth/assets/css/0.styles.aa31e347.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/./growth/" class="home-link router-link-active"><!----> <span class="site-name">Yakamoz</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/./growth/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/CallmeLetty" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/./growth/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://github.com/CallmeLetty" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/./growth/iOS进阶" class="sidebar-heading clickable open"><span>iOS进阶</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/./growth/iOS进阶/模块化方案探究.html" class="active sidebar-link">模块化方案探究</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/./growth/iOS进阶/模块化方案探究.html#设计模式原则" class="sidebar-link">设计模式原则</a></li><li class="sidebar-sub-header"><a href="/./growth/iOS进阶/模块化方案探究.html#模块划分" class="sidebar-link">模块划分</a></li><li class="sidebar-sub-header"><a href="/./growth/iOS进阶/模块化方案探究.html#常见中间件方案" class="sidebar-link">常见中间件方案</a></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/./growth/iOS底层探究" class="sidebar-heading clickable"><span>iOS底层探究</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/./growth/iOS底层探究/GCD.html" class="sidebar-link">GCD</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h1> <p>可能大多数项目在最初开发时期，都是处于一个”一锅乱炖“的状态，UI、功能等代码糅合在一起。随着项目的发展，重构就成了必经之路。其实无论是重构还是一开始开发，我们在设计一个项目时，都需要考虑到其灵活性、复用性、复杂度、耦合度和可维护性等。</p> <p>模块化顾名思义就是将一个复杂的系统分解为多个模块。降低复杂性，降低代码的耦合度，部署方便，提高效率。目前市面上已经有许多优质的模块化方案，本文将对主流的几个模块化方案进行分析探究。</p> <ul><li>模块化的意义</li></ul> <p>- 适用于基础功能稳定、项目规模较大</p> <p>- 项目变大，编译时间长，基础模块的产品间复用</p> <p>- 多团队发布、集成、测试不变，协同开发互相依赖和冲突</p> <h2 id="设计模式原则"><a href="#设计模式原则" class="header-anchor">#</a> 设计模式原则</h2> <p>在了解模块化方案之前，还是先回顾一下设计模式的六大原则。</p> <ol><li><p><strong><strong>单一原则</strong></strong>：一个类或者一个方法只负责一项职责，尽量做到类的只有一个行为原因引起变化。（业务对象、业务逻辑拆分）</p></li> <li><p><strong><strong>里氏替换原则</strong></strong>：子类可以扩展父类的功能，但不能改变原有父类的功能。（目的：增强程序的健壮性）实际项目中，每个子类对应不同的业务含义，使父类作为参数，传递不同的子类完成不同的业务逻辑。</p></li> <li><p><strong><strong>依赖倒置原则</strong></strong>：面向接口编程；（通过<strong><strong>接口</strong></strong>或<strong><strong>抽象类</strong></strong>作为参数实现应用场景）</p></li></ol> <p>1. 上层模块不应该依赖下层模块，两者应依赖其抽象；</p> <p>2. 抽象不应该依赖实现类，实现类应该依赖抽象</p> <ol start="4"><li><strong><strong>接口隔离原则</strong></strong>：建立单一接口；（扩展为类也是一种接口，一切皆接口。复杂的接口，根据业务拆分成多个简单接口）</li></ol> <p>1. 客户端不应该依赖它不需要的接口；</p> <p>2. 类之间依赖关系应该建立在最小的接口上；</p> <ol start="5"><li><p><strong><strong>迪米特原则</strong></strong>：最少知道原则，尽量降低类与类之间的耦合；一个对象应该对其他对象有最少的了解</p></li> <li><p><strong><strong>开闭原则</strong></strong>：用抽象构建架构，用实现扩展原则。</p></li></ol> <h2 id="模块划分"><a href="#模块划分" class="header-anchor">#</a> 模块划分</h2> <p>从整体架构层面和业务解耦层面考虑，基本上工程后期都会发展成如下结构：（该图仅展示基础结构）</p> <p><img src="https://oscimg.oschina.net/oscnet/up-dd3a4bfffac5f97624e9e0bb3529cfe4dab.png" alt="https://oscimg.oschina.net/oscnet/up-dd3a4bfffac5f97624e9e0bb3529cfe4dab.png"></p> <p>如上图所示，组件化拆分层次如下</p> <ul><li><p>通用模块：通用工具。如网络，文件处理等</p></li> <li><p>基础功能模块：按功能分库，不涉及产品业务需求</p></li> <li><p>业务模块 + 接口：业务功能间相对独立，相互之间没有依赖；业务之间的逻辑Action调用只能通过中间件提供；（<a href="https://www.notion.so/c1171bc1c53c4550983b1dc3a992a5d9" target="_blank" rel="noopener noreferrer"><strong><strong>中间件方案</strong></strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>下面会详细探究）</p></li> <li><p>基础UI组件：各个业务模块依赖使用，需要保持好定制扩展的设计</p></li> <li><p>App</p></li></ul> <h1 id="中间件方案"><a href="#中间件方案" class="header-anchor">#</a> 中间件方案</h1> <h2 id="常见中间件方案"><a href="#常见中间件方案" class="header-anchor">#</a> 常见中间件方案</h2> <ol><li><p>基于路由 URL 的 UI 页面统跳管理</p></li> <li><p>基于反射的远程接口调用封装</p></li> <li><p>基于面向协议思想的服务注册方案</p></li> <li><p>基于通知的广播方案</p></li></ol> <p>上述4点参考自<a href="https://zhuanlan.zhihu.com/p/425672934" target="_blank" rel="noopener noreferrer">iOS 组件化/模块化架构设计实践<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>| URL Scheme | Target Action | Protocol - Class | NSNotificationCenter |</p> <p>| --- | --- | --- | --- |</p> <p>| - 使URL处理本地的跳转</p> <ul><li><p>通过中间层进行注册&amp;调用</p></li> <li><p>注册表无需使用反射</p></li> <li><p>非懒加载/注册表的维护/参数 | - 抽离业务逻辑</p></li> <li><p>通过中间层进行调用</p></li> <li><p>中间层使用runtime反射 | 增加Prototol Wrapper层</p></li> <li><p>中间件返回Protocol对应的Class</p></li> <li><p>解决硬编码的问题 | - 基于系统的 NSNotificationCenter- 作为前面几种方案的补充 |</p></li></ul> <h3 id="基于路由-url-的-ui-页面统跳管理"><a href="#基于路由-url-的-ui-页面统跳管理" class="header-anchor">#</a> 基于路由 URL 的 UI 页面统跳管理</h3> <ul><li><p>基本原理：将请求、功能实现等放至web界面</p></li> <li><p>应用场景：VC解耦</p></li> <li><p>优势</p></li></ul> <p>- 便于实现多端统一</p> <p>- 动态性</p> <ul><li>劣势</li></ul> <p>- 交互场景偏简单</p> <p>- 复杂参数难以传递</p> <div class="language-swift extra-class"><pre class="language-swift"><code>
<span class="token comment">// example</span>

<span class="token keyword">let</span> urlString <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&lt;https://www.baidu.com&gt;&quot;</span></span>

<span class="token keyword">if</span> <span class="token keyword">let</span> urlRequest <span class="token operator">=</span> <span class="token class-name">URLRequest</span><span class="token punctuation">(</span>urlString<span class="token punctuation">:</span> urlString<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    view<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>urlRequest<span class="token punctuation">)</span>

<span class="token punctuation">}</span>

</code></pre></div><h3 id="基于反射的远程接口调用封装"><a href="#基于反射的远程接口调用封装" class="header-anchor">#</a> 基于反射的远程接口调用封装</h3> <ul><li><p>我们知道OC是一门动态语言，Runtime是我们可以动态获取一个类的方法和属性。当然swift也是有Mirror来实现反射，此处主要以OC的反射机制来举例。</p></li> <li><p>当我们需要调用某个类的方法，但无法直接import其头文件时，就会用到反射机制。如下所示：</p></li></ul> <div class="language-objectivec extra-class"><pre class="language-objectivec"><code>
Class module <span class="token operator">=</span> <span class="token function">NSClassFromString</span><span class="token punctuation">(</span><span class="token string">@&quot;GoodsModule&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

NSArray <span class="token operator">*</span>list <span class="token operator">=</span> <span class="token punctuation">[</span>manager performSelector<span class="token punctuation">:</span><span class="token keyword">@selector</span><span class="token punctuation">(</span>getGoodsList<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre></div><ul><li>如果直接这样调用，容易出现拼写错误，且难以排查，所以常见的解决方案是写一个<strong><strong>消息转发层</strong></strong>来<strong><strong>统一封装方法调用</strong></strong>。如大名鼎鼎的<a href="https://www.notion.so/CTMediator-c0af519344fe463384267bb2b405d574" target="_blank" rel="noopener noreferrer">CTMediator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>就是用了这种方案。</li></ul> <h3 id="基于面向协议思想的服务注册方案"><a href="#基于面向协议思想的服务注册方案" class="header-anchor">#</a> 基于面向协议思想的服务注册方案</h3> <ol><li><p>方案一：通过服务注册的方式来实现远程接口调用。每个模块提供自己对外服务的协议声明，然后将此声明注册到中间层。调用方能从中间层看到存在哪些服务接口，然后直接进行调用即可。</p></li> <li><p>方案二：将功能协议和回调协议暴露给调用方，调用方可通过注册回调的方式监听数据的变化。如下所示</p></li></ol> <div class="language-swift extra-class"><pre class="language-swift"><code>
<span class="token attribute atrule">@objc</span> <span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">UserContext</span><span class="token punctuation">:</span> <span class="token class-name">NSObjectProtocol</span> <span class="token punctuation">{</span>

    <span class="token keyword">func</span> <span class="token function-definition function">getLocalUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">UserInfo</span>

  


    <span class="token keyword">func</span> <span class="token function-definition function">registerUserEventHandler</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> handler<span class="token punctuation">:</span> <span class="token class-name">UserHandler</span><span class="token punctuation">)</span>

  


    <span class="token keyword">func</span> <span class="token function-definition function">unregisterUserEventHandler</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> handler<span class="token punctuation">:</span> <span class="token class-name">UserHandler</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>

  


<span class="token attribute atrule">@objc</span> <span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">UserHandler</span><span class="token punctuation">:</span> <span class="token class-name">NSObjectProtocol</span> <span class="token punctuation">{</span>

    <span class="token attribute atrule">@objc</span> <span class="token keyword">optional</span> <span class="token keyword">func</span> <span class="token function-definition function">onRemoteUserJoined</span><span class="token punctuation">(</span>user<span class="token punctuation">:</span> <span class="token class-name">UserInfo</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>

</code></pre></div><ul><li><p>优势：协议的所有实现仍然在模块内部，所以不需要写反射代码。同时对外暴露的只有协议，符合团队协作的“面向协议编程”的思想。</p></li> <li><p>劣势：</p></li></ul> <p>- 如果服务提供方和使用方依赖的是公共模块中的同一份协议（protocol）, 当协议内容改变时，会存在所有服务依赖模块编译失败的风险。（方案一）</p> <p>- 需要一个注册过程，将 Protocol 协议与具体实现绑定起来。（方案一）</p> <h3 id="基于通知的广播方案"><a href="#基于通知的广播方案" class="header-anchor">#</a> 基于通知的广播方案</h3> <ul><li><p>基于系统的 NSNotificationCenter。</p></li> <li><p>模块化通讯方案中，更多的是把通知方案作为以上几种方案的补充。</p></li> <li><p>优势</p></li></ul> <p>- 实现简单，非常适合处理一对多的通讯场景。</p> <ul><li>劣势</li></ul> <p>- 仅适用于简单通讯场景。</p> <p>- 复杂数据传输，同步调用等方式都不太方便。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/./growth/iOS底层探究/GCD.html">
        GCD
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="./growth/assets/js/app.aeb4fdc6.js" defer></script><script src="./growth/assets/js/2.63c13255.js" defer></script><script src="./growth/assets/js/9.f112da3c.js" defer></script>
  </body>
</html>
